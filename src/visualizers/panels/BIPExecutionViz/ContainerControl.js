/*globals define, WebGMEGlobal*/
/*jshint browser: true*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Wed Apr 26 2017 17:14:44 GMT-0500 (Central Daylight Time).
 */

define([
    'blob/BlobClient',
    'js/Constants',
    'js/Utils/GMEConcepts',
    'js/NodePropertyNames',
    './BIPExecutionVizInnerPanel',
    './checkResultsConsistency',
    'q',
    'text!./SwitchableRoutesEngineOutput.json'
], function (BlobClient,
             CONSTANTS,
             GMEConcepts,
             nodePropertyNames,
             InnerPanel,
             checkResultsConsistency,
             Q,
             TEST_DATA) {

    'use strict';
    var RESULT_ATTR = 'engineOutput',
        TEST = false;

    function ContainerControl(options) {
        var self = this;
        this.logger = options.logger.fork('Control');

        this._client = options.client;
        this._widget = options.widget;
        this._layoutManager = options.layoutManager;

        this._widget.notifyUser = function (notification) {
            self._client.notifyUser(notification);
        };

        this._currentNodeId = null;
        this._panels = [];

        this._blobClient = new BlobClient({logger: this.logger.fork('BlobClient')});
        this._resultData = null;

        if (TEST === true) {
            this._resultData = JSON.parse(TEST_DATA);
        }

        this._step = -1;
        this._internalStep = 0;

        this._prevStep = {
            step: -1,
            internalStep: 0
        };

        this._stepDelay = 1000;

        this._core = null;
        this._coreNode = null;

        this.logger.debug('ctor finished');
    }

    ContainerControl.prototype._configureSimulation = function (nodeIds, delay) {
        var self = this,
            cnt;

        function innerPanelReady() {
            cnt -= 1;

            if (cnt === 0) {
                self._panels.forEach(function (p) {
                    p.control.initializeSimulation(self._resultData);
                    p.control.updateSettings({stepDelay: delay});
                });

                self.stepForwardBtn.enabled(true);
                self.stepBackBtn.enabled(false);
                self._step = 0;
            }

            if (cnt < 0) {
                self.logger.error('cnt < ', cnt);
            }
        }

        if (TEST === true) {
            nodeIds = ['/f/t/1'];
        }

        cnt = nodeIds.length;

        nodeIds.forEach(function (nodeId) {
            var p = new InnerPanel(self._layoutManager, {client: self._client});

            self._panels.push(p);
            self._widget.addInnerPanel(p);

            p.control.uiLoaded = innerPanelReady;
            p.control.selectedObjectChanged(nodeId);
        });
    };

    ContainerControl.prototype._stepSimulation = function (back) {
        var self = this,
            promises;

        self.stepForwardBtn.enabled(false);
        self.stepBackBtn.enabled(false);

        promises = this._panels.map(function (p) {
            var step = back ? self._prevStep.step : self._step,
                internalStep = back ? self._prevStep.internalStep : self._internalStep;

            return p.control.stepSimulation(self._resultData.output[step], internalStep, back);
        });

        Q.all(promises)
            .then(function (/*res*/) {
                var maxStep;

                if (back) {
                    self._step = self._prevStep.step;
                    self._internalStep = self._prevStep.internalStep;

                    if (self._prevStep.internalStep > 0) {
                        self._prevStep.internalStep -= 1;
                    } else {
                        self._prevStep.step -= 1;
                        if (self._prevStep.step > -1) {
                            maxStep = self._getMaxInternalSteps(self._resultData.output[self._prevStep.step]);
                            self._prevStep.internalStep = maxStep - 1;
                        }
                    }

                } else {
                    self._prevStep.step = self._step;
                    self._prevStep.internalStep = self._internalStep;
                    maxStep = self._getMaxInternalSteps(self._resultData.output[self._step]);

                    if (self._internalStep < maxStep - 1) {
                        self._internalStep += 1;
                    } else {
                        self._internalStep = 0;
                        self._step += 1;
                    }
                }

                self.stepForwardBtn.enabled(true);
                self.stepBackBtn.enabled(true);

                if (self._prevStep.step === -1) {
                    self.stepBackBtn.enabled(false);
                } else if (self._step === self._resultData.output.length) {
                    self.stepForwardBtn.enabled(false);
                }
            })
            .catch(function (err) {
                self.logger.error('Simulation step failed!', err);
            });
    };

    ContainerControl.prototype._getMaxInternalSteps = function (stepData) {
        return Object.keys(stepData)
            .map(function (componentId) {
                // For each component ..
                return Object.keys(stepData[componentId].transitions)
                    .map(function (instanceId) {
                        // .. check the internal steps for the instances ..
                        return stepData[componentId].transitions[instanceId].length;
                    })
                    .reduce(function (max, curr) {
                        // .. and collect the longest ..
                        return curr > max ? curr : max;
                    }, 0);
            })
            .reduce(function (max, curr) {
                // .. finally return the maximum of these.
                return curr > max ? curr : max;
            }, 0);
    };

    ContainerControl.prototype.selectedObjectChanged = function (nodeId) {
        var self = this;

        this._panels.forEach(function (p) {
            p.destroy();
        });

        this._configured = false;
        this._panels = [];
        // Remove current territory patterns
        if (self._currentNodeId) {
            self._client.removeUI(self._territoryId);
        }

        self._currentNodeId = nodeId;
        self._currentNodeParentId = undefined;

        if (typeof self._currentNodeId === 'string') {
            // Put new node's info into territory rules
            self._selfPatterns = {};
            self._selfPatterns[nodeId] = {children: 0};  // Territory "rule"

            self._territoryId = self._client.addUI(self, function (events) {
                self._eventCallback(events);
            });

            // Update the territory
            self._client.updateTerritory(self._territoryId, self._selfPatterns);
        }
    };

    /* * * * * * * * Node Event Handling * * * * * * * */
    ContainerControl.prototype._eventCallback = function (events) {
        var i = events ? events.length : 0,
            event;

        while (i--) {
            event = events[i];
            switch (event.etype) {

                case CONSTANTS.TERRITORY_EVENT_LOAD:
                    this._onLoad(event.eid);
                    break;
                case CONSTANTS.TERRITORY_EVENT_UPDATE:
                    this._onUpdate(event.eid);
                    break;
                case CONSTANTS.TERRITORY_EVENT_UNLOAD:
                    this._onUnload(event.eid);
                    break;
                default:
                    break;
            }
        }
    };

    ContainerControl.prototype._onLoad = function (gmeId) {
        var self = this,
            desc = this._getObjectDescriptor(gmeId);

        this._resultData = null;

        self._widget.setTitle(desc.name);
        this._widget.showProgressbar();

        if (desc.blobHash) {
            this._blobClient.getObjectAsJSON(desc.blobHash)
                .then(function (resultData) {
                    self._resultData = resultData;
                    self._client.notifyUser({
                        message: 'Current model has attached results!',
                        severity: 'success'
                    });

                    self._client.notifyUser({
                        message: 'Looking for component types in model.',
                        severity: 'info'
                    });

                    return Q.nfcall(self._client.getCoreInstance, {});
                })
                .then(function (coreData) {
                    coreData.nodePath = self._currentNodeId;
                    return checkResultsConsistency(coreData, self._resultData);
                })
                .then(function (result) {
                    self._widget.hideProgressbar();
                    if (result.violation) {
                        self._client.notifyUser(result.violation);
                    } else {
                        self._client.notifyUser({
                            severity: 'success',
                            message: 'Current model is consistent with results!'
                        });
                    }

                    self._widget.populateConfigure(result.componentTypes, function (nodeIds, delay) {
                        self._configureSimulation(nodeIds, delay);
                    });
                })
                .catch(function (err) {
                    self._client.notifyUser({
                        message: 'Failed obtaining engineOutput from Project.',
                        severity: 'error'
                    });

                    self.logger.error(err);
                    self._widget.hideProgressbar();
                });

        } else {
            this._widget.hideProgressbar();
        }
    };

    ContainerControl.prototype._onUpdate = function (gmeId) {
        this._client.notifyUser({
            message: 'Updates are taking place in model - this might lead to outdated results!',
            severity: 'warning'
        });
    };

    ContainerControl.prototype._onUnload = function (gmeId) {
        if (this._configured) {
            this._widget.nodeRemoved();
        }
    };

    ContainerControl.prototype._getObjectDescriptor = function (nodeId) {
        var node = this._client.getNode(nodeId),
            objDescriptor;

        if (node) {
            objDescriptor = {
                id: node.getId(),
                name: node.getAttribute(nodePropertyNames.Attributes.name),
                blobHash: node.getAttribute(RESULT_ATTR),
                childrenIds: node.getChildrenIds(),
                parentId: node.getParentId()
            };
        }

        return objDescriptor;
    };

    ContainerControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
        if (this._currentNodeId === activeObjectId) {
            // The same node selected as before - do not trigger
        } else {
            this.selectedObjectChanged(activeObjectId);
        }
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    ContainerControl.prototype.destroy = function () {
        this._detachClientEventListeners();
        this._removeToolbarItems();
        this._client.removeUI(this._territoryId);
    };

    ContainerControl.prototype._attachClientEventListeners = function () {
        this._detachClientEventListeners();
        WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
    };

    ContainerControl.prototype._detachClientEventListeners = function () {
        WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
    };

    ContainerControl.prototype.onActivate = function () {
        this._attachClientEventListeners();
        this._displayToolbarItems();

        if (typeof this._currentNodeId === 'string') {
            WebGMEGlobal.State.registerActiveObject(this._currentNodeId, {suppressVisualizerFromNode: true});
        }
    };

    ContainerControl.prototype.onDeactivate = function () {
        this._detachClientEventListeners();
        this._hideToolbarItems();
    };

    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    ContainerControl.prototype._displayToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].show();
            }
        } else {
            this._initializeToolbar();
        }
    };

    ContainerControl.prototype._hideToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].hide();
            }
        }
    };

    ContainerControl.prototype._removeToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].destroy();
            }
        }
    };

    ContainerControl.prototype._initializeToolbar = function () {
        var toolBar = WebGMEGlobal.Toolbar,
            self = this;

        this._toolbarItems = [];

        // Settings btn
        this.configureSimulationBtn = toolBar.addButton(
            {
                title: 'Settings',
                icon: 'fa fa-cogs',
                clickFn: function (/*data*/) {
                    alert('TODO: Implement settings that can change during simulation');
                }
            });

        this._toolbarItems.push(this.configureSimulationBtn);

        // step back btn
        this.stepBackBtn = toolBar.addButton(
            {
                title: 'Step backward',
                icon: 'fa fa-step-backward',
                clickFn: function (/*data*/) {
                    self._stepSimulation(true);
                }
            });

        this._toolbarItems.push(this.stepBackBtn);
        this.stepBackBtn.enabled(false);

        // play btn
        // this.startSimulationBtn = toolBar.addButton(
        //     {
        //         title: 'Play simulation',
        //         icon: 'fa fa-play-circle-o',
        //         clickFn: function (/*data*/) {
        //             self._stepSimulation();
        //         }
        //     });
        //
        // this._toolbarItems.push(this.startSimulationBtn);
        // this.startSimulationBtn.enabled(false);
        //
        // this.pauseSimulationBtn = toolBar.addButton(
        //     {
        //         title: 'Pause simulation',
        //         icon: 'fa fa-pause-circle-o',
        //         clickFn: function (/*data*/) {
        //             self._stepSimulation();
        //         }
        //     });
        //
        // this._toolbarItems.push(this.pauseSimulationBtn);
        // this.pauseSimulationBtn.hide();

        // step forward btn
        this.stepForwardBtn = toolBar.addButton(
            {
                title: 'Step forward',
                icon: 'fa fa-step-forward',
                clickFn: function (/*data*/) {
                    self._stepSimulation();
                }
            });

        this._toolbarItems.push(this.stepForwardBtn);
        this.stepForwardBtn.enabled(false);


        this._toolbarInitialized = true;
    };

    return ContainerControl;
});
